# Implementation-of-Transaction-Manager
Implementation of Transaction Manager using two phase locking protocol to guarantee serializability


I.	INTRODUCTION:

A transaction manager is a part of an application that controls the coordination of transactions over one or more resources. The transaction manager is responsible for creating transaction objects and managing their durability and atomicity. Transaction managers keep track of all the resource managers that are enlisted in a transaction. In databases and transaction processing, two-phase locking (2PL) is a concurrency control method that guarantees serializability. It is also the name of the resulting set of database transaction schedules(histories). The protocol utilizes locks, applied by a transaction to data, which may block (interpreted as signals to stop) other transactions from accessing the same data during the transaction's life. The 2PL protocol, locks are applied and removed in two phases, Expanding phase: locks are a and no locks are released, Shrinking phase: locks are released and no locks are acquired. Two types of locks are utilized by the basic protocol: Shared and Exclusive locks. Refinements of the basic protocol may utilize more lock types. Using locks that block processes, 2PL may be subject to deadlocks that result from the mutual blocking of two or more transactions. Two major types of locks utilized are: Write-lock (exclusive lock) is associated with a database object by a transaction (Terminology: "the transaction locks the object," or "acquires lock for it") before writing (inserting/modifying/deleting) this object. Read-lock (shared lock) is associated with a database object by a transaction before reading (retrieving the state of) this object.



II.	IMPEMENTATION OF THE CODE
In Zgt_tc.C we implement readtx(), writetx(), aborttx(), committx(), do_commit_abort(), perform_readwrite(), set_lock(). First we get the transaction id, object number and count for that transaction. In the beginning of the transaction we set the obno=0 and SGNO=1. The following are the states used in a transaction: 

•	TR_ACTIVE or processing (represented as “P”) 
•	TR_WAIT (represented as “W”) 
•	TR_ABORT (represented as “A”) and 
•	TR_END (represented as “E”) This is the state while commit is going on. 

For read operation we retrieve the existing transaction and check if the transaction is in processing state ‘P’. If it is in P state we set the lock in Shared mode . After finishing the operation we exit that thread that is currently running using pthread_exit(NULL). The writetx() method is same as  readtx() method. If the transaction is in “Processing“ state  we set the lock in "Exclusive" mode and carry the operation. In the perform_readwrite() based on the lockmode we perform the read and write operation. If the lockmode is in Exclusive mode then we perform write operation the object value here is incremented by 1 and in case of read operation in shared mode the object value is decremented by 1. The results of each operation is printed and the logfile is flushed after the operation is completed. In the Zgt_tm.C the TxWrite operation is same as the TxRead method. In aborttx function(zgt_tx.c) and the committx  we change the status of the transaction to 'A' and 'E' respectively  and then we call the do_commit_abort() method. In do_commit_abort() method, we release all the locks held by the transaction by using free_locks() method and then we remove the transaction using remove_tx() method. We also release all the transactions waiting  on the commit/abort transactions. This is done by retrieving the list of transactions that are waiting on this transaction using zgt_nwait() method and then we release the semaphores using zgt_v(0). In setlock() method we try to find if the requested object is already present in the hash table using the transaction id of the current transaction. This is done using the findt() method. If the method is successful then we call perform_readwrite function to perform the read/write operation.We also needto find if the object is locked by some other transaction. For this we use the find() method. If the object is not present in the hash table then we add the transaction using the add() method and then we call perform_readwrite(). If the object is present in the hash table and if its locked by some other transaction then then we need to check the lockmode of the transaction . If both transaction has shared lock then we call perform_readwrite() operation since there can be more than one transaction can perform reading operation in the critical section. If the transaction holding the lock on the requested object is an 'exclusive lock', then we put our current transaction in wait status. The current transaction resumes operation after the transaction aborts/commits and releases the lock on the requested object and the semaphores are release form all the waiting transaction


